import { create } from 'zustand';
import { mockProperties } from '../lib/supabase';
import toast from 'react-hot-toast';

export const usePropertyStore = create((set, get) => ({
  properties: [],
  loading: false,
  selectedProperty: null,

  // Get all properties
  getAllProperties: async () => {
    set({ loading: true });
    try {
      // In a real app, this would be an API call
      // For now, we'll use mock data with some additional properties
      const enhancedMockProperties = mockProperties.map(property => ({
        ...property,
        status: 'active',
        createdAt: new Date(),
        updatedAt: new Date()
      }));

      set({ properties: enhancedMockProperties, loading: false });
      console.log('Properties loaded:', enhancedMockProperties.length);
    } catch (error) {
      console.error('Failed to load properties:', error);
      toast.error('Failed to load properties');
      set({ loading: false });
    }
  },

  // Create new property
  createProperty: async (propertyData) => {
    set({ loading: true });
    try {
      const newProperty = {
        id: Date.now(), // In real app, this would be generated by the backend
        ...propertyData,
        createdAt: new Date(),
        updatedAt: new Date(),
        avgRating: 0,
        reviewCount: 0,
        minPrice: propertyData.rooms?.length > 0 
          ? Math.min(...propertyData.rooms.map(room => room.price_per_night)) 
          : 0
      };

      set(state => ({
        properties: [...state.properties, newProperty],
        loading: false
      }));

      toast.success('Property created successfully');
      return { success: true, property: newProperty };
    } catch (error) {
      console.error('Failed to create property:', error);
      toast.error('Failed to create property');
      set({ loading: false });
      return { success: false, error: error.message };
    }
  },

  // Update property
  updateProperty: async (propertyId, updates) => {
    set({ loading: true });
    try {
      set(state => ({
        properties: state.properties.map(property =>
          property.id === propertyId
            ? {
                ...property,
                ...updates,
                updatedAt: new Date(),
                minPrice: updates.rooms?.length > 0 
                  ? Math.min(...updates.rooms.map(room => room.price_per_night)) 
                  : property.minPrice
              }
            : property
        ),
        loading: false
      }));

      toast.success('Property updated successfully');
      return { success: true };
    } catch (error) {
      console.error('Failed to update property:', error);
      toast.error('Failed to update property');
      set({ loading: false });
      return { success: false, error: error.message };
    }
  },

  // Delete property
  deleteProperty: async (propertyId) => {
    try {
      set(state => ({
        properties: state.properties.filter(property => property.id !== propertyId)
      }));

      toast.success('Property deleted successfully');
      return { success: true };
    } catch (error) {
      console.error('Failed to delete property:', error);
      toast.error('Failed to delete property');
      return { success: false, error: error.message };
    }
  },

  // Get property by ID
  getPropertyById: (propertyId) => {
    const { properties } = get();
    return properties.find(property => property.id === propertyId);
  },

  // Set selected property
  setSelectedProperty: (property) => {
    set({ selectedProperty: property });
  },

  // Search properties
  searchProperties: async (searchParams) => {
    set({ loading: true });
    try {
      const { properties } = get();
      let filtered = properties;

      // Apply filters
      if (searchParams.location) {
        filtered = filtered.filter(property =>
          property.city.toLowerCase().includes(searchParams.location.toLowerCase()) ||
          property.country.toLowerCase().includes(searchParams.location.toLowerCase()) ||
          property.name.toLowerCase().includes(searchParams.location.toLowerCase())
        );
      }

      if (searchParams.type) {
        filtered = filtered.filter(property => property.type === searchParams.type);
      }

      if (searchParams.minPrice !== undefined) {
        filtered = filtered.filter(property => property.minPrice >= searchParams.minPrice);
      }

      if (searchParams.maxPrice !== undefined) {
        filtered = filtered.filter(property => property.minPrice <= searchParams.maxPrice);
      }

      if (searchParams.amenities && searchParams.amenities.length > 0) {
        filtered = filtered.filter(property =>
          searchParams.amenities.every(amenity => property.amenities.includes(amenity))
        );
      }

      set({ loading: false });
      return { success: true, properties: filtered };
    } catch (error) {
      console.error('Failed to search properties:', error);
      set({ loading: false });
      return { success: false, error: error.message };
    }
  },

  // Update property status
  updatePropertyStatus: async (propertyId, status) => {
    try {
      set(state => ({
        properties: state.properties.map(property =>
          property.id === propertyId
            ? { ...property, status, updatedAt: new Date() }
            : property
        )
      }));

      toast.success('Property status updated');
      return { success: true };
    } catch (error) {
      console.error('Failed to update property status:', error);
      toast.error('Failed to update property status');
      return { success: false, error: error.message };
    }
  },

  // Get properties by status
  getPropertiesByStatus: (status) => {
    const { properties } = get();
    return properties.filter(property => property.status === status);
  },

  // Get properties by type
  getPropertiesByType: (type) => {
    const { properties } = get();
    return properties.filter(property => property.type === type);
  }
}));